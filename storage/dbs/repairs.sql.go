// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repairs.sql

package dbs

import (
	"context"
	"database/sql"
)

const listOrders = `-- name: ListOrders :many
SELECT 
    ro.repair_id,
    ro.repair_number,
    ro.start_date,
    ro.notes,
    ro.total_sum,
    rs.title AS repair_status,
    ps.title AS payment_status,
    concat(emp.first_name, ' ', emp.last_name) AS assigned_employee,
    cc.registration_number,
    cc.description AS vehicle_description,
    concat(cl.first_name, ' ', cl.last_name) AS client_name,
    car.model AS vehicle_model,
    car.year AS vehicle_year,
    ser.name AS service_name,
    srep.quantity AS service_quantity,
    srep.completion_date,
    srep.service_total_price,
    inv.amount AS inventory_amount,
    det.description AS inventory_item_description,
    det.price AS detail_item_price_per_unit,
    invdet.quantity AS inventory_item_quantity,
    ss.address  as address 
FROM 
    public.repair_order ro
LEFT JOIN public.repair_status rs ON ro.repair_status_id = rs.status_id
LEFT JOIN public.payment_status ps ON ro.payment_status_id = ps.status_id
LEFT JOIN public.employee emp ON ro.employee_id = emp.employee_id
LEFT JOIN public.car_client cc ON ro.car_client_id = cc.car_client_id
LEFT JOIN public.client cl ON cc.client_id = cl.client_id
LEFT JOIN public.car car ON cc.car_id = car.car_id
LEFT JOIN public.service_repairs srep ON ro.repair_id = srep.repair_id
LEFT JOIN public.service ser ON srep.service_id = ser.service_id
LEFT JOIN public.service_inventory inv ON srep.service_repairs_id = inv.service_repair_id
LEFT JOIN public.inventory invdet ON inv.inventory_id = invdet.inventory_id
LEFT JOIN public.detail det ON invdet.detail_id = det.detail_id
left join public.service_station ss on emp.service_station_id = ss.station_id 
ORDER BY 
    ro.repair_id
`

type ListOrdersRow struct {
	RepairID                 int32
	RepairNumber             sql.NullString
	StartDate                sql.NullTime
	Notes                    sql.NullString
	TotalSum                 sql.NullString
	RepairStatus             sql.NullString
	PaymentStatus            sql.NullString
	AssignedEmployee         interface{}
	RegistrationNumber       sql.NullString
	VehicleDescription       sql.NullString
	ClientName               interface{}
	VehicleModel             sql.NullString
	VehicleYear              sql.NullInt32
	ServiceName              sql.NullString
	ServiceQuantity          sql.NullInt32
	CompletionDate           sql.NullTime
	ServiceTotalPrice        sql.NullString
	InventoryAmount          sql.NullString
	InventoryItemDescription sql.NullString
	DetailItemPricePerUnit   sql.NullString
	InventoryItemQuantity    sql.NullInt32
	Address                  sql.NullString
}

func (q *Queries) ListOrders(ctx context.Context) ([]ListOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.RepairID,
			&i.RepairNumber,
			&i.StartDate,
			&i.Notes,
			&i.TotalSum,
			&i.RepairStatus,
			&i.PaymentStatus,
			&i.AssignedEmployee,
			&i.RegistrationNumber,
			&i.VehicleDescription,
			&i.ClientName,
			&i.VehicleModel,
			&i.VehicleYear,
			&i.ServiceName,
			&i.ServiceQuantity,
			&i.CompletionDate,
			&i.ServiceTotalPrice,
			&i.InventoryAmount,
			&i.InventoryItemDescription,
			&i.DetailItemPricePerUnit,
			&i.InventoryItemQuantity,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
